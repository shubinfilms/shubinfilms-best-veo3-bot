# bot.py
# --- Best VEO3 bot (Telegram) ---
# –°–æ–≤–º–µ—Å—Ç–∏–º —Å python-telegram-bot 20.7
# –§—É–Ω–∫—Ü–∏–∏:
# ‚Ä¢ VEO –ø–æ —Ç–µ–∫—Å—Ç—É –∏ –ø–æ —Ñ–æ—Ç–æ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å—É (—á–µ—Ä–µ–∑ File Upload API => –Ω–µ—Ç 400 Image fetch failed)
# ‚Ä¢ Midjourney –ø–æ —Å–µ–ª—Ñ–∏ (img2img) —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
# ‚Ä¢ –ö–Ω–æ–ø–æ—á–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è, –≤—ã–±–æ—Ä –∞—Å–ø–µ–∫—Ç–æ–≤ –∏ —Å–∫–æ—Ä–æ—Å—Ç–µ–π, –∞–Ω—Ç–∏-–¥–∞–±–ª–∫–ª–∏–∫
# ‚Ä¢ /health –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
# -------------------------------------------------------------

from __future__ import annotations

import os
import io
import json
import time
import asyncio
import logging
from typing import Optional, Tuple, List, Dict, Any

import requests
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputMediaVideo,
    InputMediaPhoto,
)
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)

# ========================= ENV & LOG =========================

TELEGRAM_TOKEN: str = os.getenv("TELEGRAM_TOKEN", "").strip()
KIE_API_KEY: str = os.getenv("KIE_API_KEY", "").strip()
KIE_BASE: str = os.getenv("KIE_BASE", "https://api.kie.ai").rstrip("/")

if not TELEGRAM_TOKEN or not KIE_API_KEY:
    raise SystemExit("Set TELEGRAM_TOKEN and KIE_API_KEY env variables")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
log = logging.getLogger("best-veo3-bot")

# ========================= STATE (in-memory) =========================

# –ü—Ä–æ—Å—Ç–æ–π –∏–Ω-–º–µ–º–æ—Ä–∏ —Å—Ç–µ–π—Ç –ø–æ user_id. –î–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞ –º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –ë–î/Redis.
USERS: Dict[int, Dict[str, Any]] = {}

def get_state(uid: int) -> Dict[str, Any]:
    """
    –í–µ—Ä–Ω—ë—Ç (–∏–ª–∏ —Å–æ–∑–¥–∞—Å—Ç) —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    return USERS.setdefault(
        uid,
        {
            "mode": None,           # "veo_text" | "veo_photo" | "mj_face"
            "prompt": "",
            "photo_file_id": None,  # file_id –∏–∑ Telegram –¥–ª—è —Ñ–æ—Ç–æ/—Å–µ–ª—Ñ–∏
            "ratio": "16:9",        # "1:1" | "16:9" | "9:16" | "3:4"
            "speed": "fast",        # VEO: "fast" | "quality"
            "mj_speed": "fast",     # MJ: "relaxed" | "fast" | "turbo"
            "mj_version": "7",
            "stylization": 50,      # 0..1000
            "weirdness": 0,         # 0..3000
            "variety": 5,           # 0..100
            "_busy": False,         # –∞–Ω—Ç–∏-–¥–∞–±–ª–∫–ª–∏–∫
            "_await_prompt": False,
            "_await_photo": False,
        },
    )

# ========================= Keyboards =========================

def kb_main() -> InlineKeyboardMarkup:
    """
    –ì–ª–∞–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞: –≤—ã–±–æ—Ä —Ä–µ–∂–∏–º–æ–≤.
    """
    rows = [
        [InlineKeyboardButton("üé¨ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ —Ç–µ–∫—Å—Ç—É (VEO)", callback_data="veo_text")],
        [InlineKeyboardButton("üñºÔ∏è –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ —Ñ–æ—Ç–æ (VEO)", callback_data="veo_photo")],
        [InlineKeyboardButton("üë§ –§–æ—Ç–æ —Å –≤–∞—à–∏–º –ª–∏—Ü–æ–º (MJ)", callback_data="mj_face")],
        [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", url="https://kie.ai/pricing")],
    ]
    return InlineKeyboardMarkup(rows)

def kb_params_common(st: Dict[str, Any], for_mj: bool) -> InlineKeyboardMarkup:
    """
    –ï–¥–∏–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:
    ‚Ä¢ –æ–±—â–∏–µ: –∞—Å–ø–µ–∫—Ç-—Ä–∞—Ç–∏–æ, —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ
    ‚Ä¢ –¥–ª—è VEO ‚Äî speed fast/quality
    ‚Ä¢ –¥–ª—è MJ  ‚Äî speed relaxed/fast/turbo
    """
    aspect_row = [
        InlineKeyboardButton("1:1",  callback_data="ratio:1:1"),
        InlineKeyboardButton("16:9", callback_data="ratio:16:9"),
        InlineKeyboardButton("9:16", callback_data="ratio:9:16"),
        InlineKeyboardButton("3:4",  callback_data="ratio:3:4"),
    ]
    prompt_photo_row = [
        InlineKeyboardButton("üß† –ò–∑–º. –ø—Ä–æ–º–ø—Ç", callback_data="prompt_edit"),
        InlineKeyboardButton("üì∏ –î–æ–±–∞–≤–∏—Ç—å/–£–¥–∞–ª–∏—Ç—å —Å–µ–ª—Ñ–∏" if for_mj else "üì∏ –î–æ–±–∞–≤–∏—Ç—å/–£–¥–∞–ª–∏—Ç—å —Ñ–æ—Ç–æ",
                             callback_data="photo_toggle"),
    ]

    if for_mj:
        speed_row = [
            InlineKeyboardButton(("üê¢ relaxed" + (" ‚úÖ" if st["mj_speed"] == "relaxed" else "")), callback_data="mjspeed:relaxed"),
            InlineKeyboardButton(("‚ö° fast"    + (" ‚úÖ" if st["mj_speed"] == "fast"    else "")), callback_data="mjspeed:fast"),
            InlineKeyboardButton(("üöÄ turbo"   + (" ‚úÖ" if st["mj_speed"] == "turbo"   else "")), callback_data="mjspeed:turbo"),
        ]
        action_row = [
            InlineKeyboardButton("üß© –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ", callback_data="run_mj"),
            InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back"),
        ]
    else:
        speed_row = [
            InlineKeyboardButton(("‚ö° fast"    + (" ‚úÖ" if st["speed"] == "fast"    else "")), callback_data="speed:fast"),
            InlineKeyboardButton(("üíé quality" + (" ‚úÖ" if st["speed"] == "quality" else "")), callback_data="speed:quality"),
        ]
        action_row = [
            InlineKeyboardButton("üé¨ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ", callback_data="run_veo"),
            InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back"),
        ]

    pay_row = [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", url="https://kie.ai/pricing")]
    return InlineKeyboardMarkup([prompt_photo_row, aspect_row, speed_row, action_row, pay_row])

# ========================= Helpers: Telegram file & KIE upload =========================

def tg_file_direct_url(bot_token: str, file_id: str) -> str:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä—è–º–æ–π URL —Ñ–∞–π–ª–∞ Telegram (—á–µ—Ä–µ–∑ getFile).
    """
    from telegram import Bot
    bot = Bot(bot_token)
    file = bot.get_file(file_id)
    return f"https://api.telegram.org/file/bot{bot_token}/{file.file_path}"

def kie_try_upload_endpoints(data_bytes: bytes, filename: str = "image.jpg", mime: str = "image/jpeg") -> str:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –Ω–∞ KIE —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É—Å—Ç–æ–π—á–∏–≤—ã–π fileUrl, –ø—Ä–∏–≥–æ–¥–Ω—ã–π –¥–ª—è MJ/VEO.
    """
    endpoints = [
        f"{KIE_BASE}/api/v1/file/upload",
        f"{KIE_BASE}/common-api/file/upload",
        f"{KIE_BASE}/api/v1/common/file/upload",
    ]
    last_error = None
    for url in endpoints:
        try:
            resp = requests.post(
                url,
                headers={"Authorization": f"Bearer {KIE_API_KEY}"},
                files={"file": (filename, io.BytesIO(data_bytes), mime)},
                timeout=60,
            )
            data = resp.json()
            if resp.ok and data.get("code") == 200 and data.get("data", {}).get("fileUrl"):
                return data["data"]["fileUrl"]
            last_error = f"{url} -> {data}"
        except Exception as e:
            last_error = f"{url} -> {e}"
    raise RuntimeError(f"KIE upload failed: {last_error}")

def upload_tg_photo_to_kie(bot_token: str, file_id: str) -> str:
    """
    –°–∫–∞—á–∏–≤–∞–µ—Ç —Ñ–æ—Ç–æ –∏–∑ Telegram –∏ –∑–∞–≥—Ä—É–∂–∞–µ—Ç –Ω–∞ KIE. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç fileUrl.
    """
    direct = tg_file_direct_url(bot_token, file_id)
    r = requests.get(direct, timeout=30)
    r.raise_for_status()
    return kie_try_upload_endpoints(r.content)

# ========================= KIE: Midjourney =========================

def _clamp_int(v: Any, lo: int, hi: int) -> int:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–∏–≤–æ–¥–∏–º –∫ int –∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω.
    """
    try:
        v = int(v)
    except Exception:
        v = lo
    return max(lo, min(hi, v))

def mj_generate(
    *,
    task_type: str,           # 'mj_txt2img' | 'mj_img2img' | 'mj_video'
    prompt: str,
    aspect_ratio: str,        # '1:1'|'16:9'|'9:16'|'3:4' + –µ—â—ë –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º
    speed: str,               # 'relaxed'|'fast'|'turbo'
    version: str,             # '7'|'6.1'|'6'|'5.2'|'5.1'|'niji6'
    file_url: Optional[str] = None,
    stylization: int = 50,
    weirdness: int = 0,
    variety: int = 5,
) -> Dict[str, Any]:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞—á—É –≤ MJ —á–µ—Ä–µ–∑ KIE.
    """
    payload: Dict[str, Any] = {
        "taskType": task_type,
        "prompt": prompt[:2000],
        "aspectRatio": aspect_ratio,
        "speed": speed,
        "version": version,
        "stylization": _clamp_int(stylization, 0, 1000),
        "weirdness": _clamp_int(weirdness, 0, 3000),
        "variety": _clamp_int(variety, 0, 100),
        "enableTranslation": False,
    }
    if file_url:
        payload["fileUrl"] = file_url

    resp = requests.post(
        f"{KIE_BASE}/api/v1/mj/generate",
        headers={"Authorization": f"Bearer {KIE_API_KEY}", "Content-Type": "application/json"},
        json=payload,
        timeout=60,
    )
    try:
        return resp.json()
    except Exception:
        return {"code": 500, "msg": f"http error {resp.status_code}"}

def kie_poll(kind: str, task_id: str) -> Dict[str, Any]:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–ø—Ä–æ—Å –∑–∞–¥–∞—á KIE.
    kind: "mj" | "veo"
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å:
      ‚Ä¢ final: True/False ‚Äî —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      ‚Ä¢ ok: True/False ‚Äî —É—Å–ø–µ—Ö –ª–∏
      ‚Ä¢ data/error ‚Äî –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏
    """
    r = requests.get(
        f"{KIE_BASE}/api/v1/{kind}/record-info",
        params={"taskId": task_id},
        headers={"Authorization": f"Bearer {KIE_API_KEY}"},
        timeout=30,
    )
    try:
        j = r.json()
    except Exception:
        return {"final": True, "ok": False, "error": f"http {r.status_code}"}

    if j.get("code") != 200:
        return {"final": True, "ok": False, "error": f"{j.get('code')} {j.get('msg')}"}

    data = j.get("data") or {}
    flag = data.get("successFlag")
    if flag == 0:  # –∏–¥—ë—Ç —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
        return {"final": False, "ok": True, "data": data}
    if flag == 1:  # –≥–æ—Ç–æ–≤–æ
        return {"final": True, "ok": True, "data": data}
    if flag in (2, 3):  # –æ—à–∏–±–∫–∏
        return {"final": True, "ok": False, "error": data.get("errorMessage") or f"flag={flag}", "data": data}
    # –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ
    return {"final": False, "ok": True, "data": data}

def extract_result_urls(data: Dict[str, Any]) -> List[str]:
    """
    –ê–∫–∫—É—Ä–∞—Ç–Ω–æ –≤—ã–∫–æ–≤—ã—Ä–∏–≤–∞–µ–º —Å—Å—ã–ª–∫–∏ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∫–ª—é—á–µ–π: resultUrls | result_urls.
    """
    out: List[str] = []
    res = (data or {}).get("resultInfoJson") or {}
    for key in ("resultUrls", "result_urls"):
        v = res.get(key)
        if isinstance(v, list):
            for x in v:
                if isinstance(x, str):
                    out.append(x)
                elif isinstance(x, dict) and x.get("resultUrl"):
                    out.append(x["resultUrl"])
    return out

# ========================= KIE: Veo 3 =========================

def veo_generate_text(prompt: str, aspect_ratio: str, speed: str) -> Dict[str, Any]:
    """
    VEO –ø–æ —Ç–µ–∫—Å—Ç—É.
    """
    payload = {
        "taskType": "veo_txt2vid",  # –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è —É –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞; —É–∫–∞–∂–∏ —Å–≤–æ–π –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        "prompt": prompt[:2000],
        "aspectRatio": aspect_ratio,
        "speed": "fast" if speed == "fast" else "quality",
    }
    r = requests.post(
        f"{KIE_BASE}/api/v1/veo/generate",
        headers={"Authorization": f"Bearer {KIE_API_KEY}", "Content-Type": "application/json"},
        json=payload, timeout=60
    )
    try:
        return r.json()
    except Exception:
        return {"code": 500, "msg": f"http error {r.status_code}"}

def veo_generate_with_ref(prompt: str, aspect_ratio: str, speed: str, file_url: str) -> Dict[str, Any]:
    """
    VEO –ø–æ —Ñ–æ—Ç–æ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å—É.
    """
    payload = {
        "taskType": "veo_img_ref",  # –ø—Ä–∏ –∏–Ω–æ–π —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ–º–µ–Ω—è–π –∑–Ω–∞—á–µ–Ω–∏–µ
        "prompt": prompt[:2000],
        "aspectRatio": aspect_ratio,
        "speed": "fast" if speed == "fast" else "quality",
        "fileUrl": file_url,
    }
    r = requests.post(
        f"{KIE_BASE}/api/v1/veo/generate",
        headers={"Authorization": f"Bearer {KIE_API_KEY}", "Content-Type": "application/json"},
        json=payload, timeout=60
    )
    try:
        return r.json()
    except Exception:
        return {"code": 500, "msg": f"http error {r.status_code}"}

# ========================= UI Texts =========================

WELCOME = (
    "üé• *Veo 3 ‚Äî —Å—É–ø–µ—Ä-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ*\n"
    "–û–ø–∏—à–∏ –∏–¥–µ—é ‚Äî –ø–æ–ª—É—á–∏—à—å –≥–æ—Ç–æ–≤—ã–π –∫–ª–∏–ø. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è 16:9 –∏ 9:16, —Ä–µ–∂–∏–º—ã Fast/Quality, —Ñ–æ—Ç–æ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å.\n\n"
    "üñºÔ∏è *Midjourney* ‚Äî —Ñ–æ—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è, –≤–∫–ª—é—á–∞—è –ø–æ—Ä—Ç—Ä–µ—Ç—ã –ø–æ —Å–µ–ª—Ñ–∏.\n\n"
    "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –Ω–∏–∂–µ üëá"
)

# ========================= Handlers =========================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    /start ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ —Å–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ.
    """
    st = get_state(update.effective_user.id)
    st.update({"mode": None, "prompt": "", "photo_file_id": None, "_busy": False})
    await update.effective_message.reply_text(WELCOME, reply_markup=kb_main(), parse_mode="Markdown")

async def health(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    /health ‚Äî —É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –≤–µ—Ä—Å–∏—è PTB –∏ –ø–∏–Ω–≥ KIE –∫—Ä–µ–¥–∏—Ç–æ–≤.
    """
    import telegram
    try:
        r = requests.get(
            f"{KIE_BASE}/common-api/get-account-credits",
            headers={"Authorization": f"Bearer {KIE_API_KEY}"},
            timeout=15,
        )
        ok = r.ok
        msg = r.text[:180]
    except Exception as e:
        ok = False
        msg = str(e)[:180]

    await update.effective_message.reply_text(
        f"PTB: {getattr(telegram, '__version__', 'unknown')}\n"
        f"KIE ping: {'OK' if ok else 'FAIL'}\n{msg}"
    )

async def on_cb(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Å–µ—Ö callback-–∫–Ω–æ–ø–æ–∫.
    """
    query = update.callback_query
    await query.answer()
    uid = update.effective_user.id
    st = get_state(uid)
    data = query.data

    # –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    if data == "back":
        st["mode"] = None
        await query.edit_message_text(WELCOME, reply_markup=kb_main(), parse_mode="Markdown")
        return

    # –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞
    if data in ("veo_text", "veo_photo", "mj_face"):
        st["mode"] = data
        header = {
            "veo_text":  "üé¨ VEO ‚Äî –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ä–µ–Ω–¥–µ—Ä—É (–ø–æ —Ç–µ–∫—Å—Ç—É)",
            "veo_photo": "üñºÔ∏è VEO ‚Äî –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ä–µ–Ω–¥–µ—Ä—É (–ø–æ —Ñ–æ—Ç–æ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å—É)",
            "mj_face":   "üë§ MJ ‚Äî –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ä–µ–Ω–¥–µ—Ä—É (—Å–µ–ª—Ñ–∏ ‚ûú —Ñ–æ—Ç–æ)",
        }[data]
        need = "–ü—Ä–∏—à–ª–∏—Ç–µ *–ø—Ä–æ–º–ø—Ç*." if data == "veo_text" else "–ù—É–∂–Ω—ã *—Å–µ–ª—Ñ–∏* –∏ *–ø—Ä–æ–º–ø—Ç*."
        await query.edit_message_text(
            f"{header}\n{need}\n\n"
            f"üìù –ü—Ä–æ–º–ø—Ç: {st['prompt'] or '‚Äî'}\n"
            f"üì∑ –§–æ—Ç–æ: {'–µ—Å—Ç—å' if st['photo_file_id'] else '–Ω–µ—Ç'}\n"
            f"‚öôÔ∏è Aspect: {st['ratio']}\n",
            reply_markup=kb_params_common(st, for_mj=(data == "mj_face")),
            parse_mode="Markdown",
        )
        return

    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    if data.startswith("ratio:"):
        st["ratio"] = data.split(":", 1)[1]
        await query.edit_message_reply_markup(kb_params_common(st, for_mj=(st["mode"] == "mj_face")))
        return

    if data.startswith("speed:"):
        st["speed"] = data.split(":", 1)[1]
        await query.edit_message_reply_markup(kb_params_common(st, for_mj=False))
        return

    if data.startswith("mjspeed:"):
        st["mj_speed"] = data.split(":", 1)[1]
        await query.edit_message_reply_markup(kb_params_common(st, for_mj=True))
        return

    if data == "prompt_edit":
        st["_await_prompt"] = True
        await query.edit_message_text("–ü—Ä–∏—à–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø—Ä–æ–º–ø—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ä–µ–ø–ª–∏–∫–æ–π.")
        return

    if data == "photo_toggle":
        st["_await_photo"] = True
        await query.edit_message_text("–ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ (jpg/png). –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ —Ñ–æ—Ç–æ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç –ø—Ä–µ–∂–Ω–µ–µ.")
        return

    # ---- RUN VEO ----
    if data == "run_veo":
        if st["_busy"]:
            await query.message.reply_text("‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.")
            return
        if not st["prompt"]:
            await query.message.reply_text("–ù—É–∂–µ–Ω –ø—Ä–æ–º–ø—Ç.")
            return
        if st["mode"] == "veo_photo" and not st["photo_file_id"]:
            await query.message.reply_text("–ù—É–∂–Ω–æ —Ñ–æ—Ç–æ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å.")
            return

        st["_busy"] = True
        try:
            if st["mode"] == "veo_text":
                resp = veo_generate_text(st["prompt"], st["ratio"], st["speed"])
            else:
                # 1) –∑–∞–ª–∏–≤–∞–µ–º –≤ KIE; 2) –æ—Ç–¥–∞—ë–º —Å—Å—ã–ª–∫—É –≤ generate
                file_url = upload_tg_photo_to_kie(context.bot.token, st["photo_file_id"])
                resp = veo_generate_with_ref(st["prompt"], st["ratio"], st["speed"], file_url)

            if resp.get("code") != 200:
                await query.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å VEO-–∑–∞–¥–∞—á—É: {resp.get('msg')}")
                st["_busy"] = False
                return

            task_id = (resp.get("data") or {}).get("taskId")
            await query.message.reply_text(f"üöÄ –ó–∞–¥–∞—á–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ (VEO). taskId={task_id}\n‚è≥ –ò–¥—ë—Ç —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥‚Ä¶")

            # –ü—É–ª–∏–Ω–≥ —Å—Ç–∞—Ç—É—Å–∞
            for _ in range(60):  # –¥–æ ~10 –º–∏–Ω—É—Ç (6*60=600 —Å–µ–∫ –ø—Ä–∏ 10—Å —à–∞–≥–µ)
                pol = kie_poll("veo", task_id)
                if pol["final"]:
                    if pol["ok"]:
                        urls = extract_result_urls(pol["data"])
                        if urls:
                            u0 = urls[0]
                            if u0.lower().endswith((".mp4", ".mov", ".webm")):
                                await query.message.reply_video(u0, caption="‚úÖ –ì–æ—Ç–æ–≤–æ!")
                            else:
                                await query.message.reply_photo(u0, caption="‚úÖ –ì–æ—Ç–æ–≤–æ!")
                        else:
                            await query.message.reply_text("‚úÖ –ì–æ—Ç–æ–≤–æ (–Ω–æ –±–µ–∑ —Å—Å—ã–ª–æ–∫ –≤ –æ—Ç–≤–µ—Ç–µ KIE).")
                    else:
                        await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ KIE (VEO): {pol.get('error','')}")
                    break
                await asyncio.sleep(10)
        finally:
            st["_busy"] = False
        return

    # ---- RUN MJ ----
    if data == "run_mj":
        if st["_busy"]:
            await query.message.reply_text("‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.")
            return
        if not st["prompt"] or not st["photo_file_id"]:
            await query.message.reply_text("–ù—É–∂–Ω—ã —Å–µ–ª—Ñ–∏ –∏ –ø—Ä–æ–º–ø—Ç.")
            return

        st["_busy"] = True
        try:
            file_url = upload_tg_photo_to_kie(context.bot.token, st["photo_file_id"])
            resp = mj_generate(
                task_type="mj_img2img",
                prompt=st["prompt"],
                aspect_ratio=st["ratio"],
                speed=st["mj_speed"],
                version=st["mj_version"],
                file_url=file_url,
                stylization=st["stylization"],
                weirdness=st["weirdness"],
                variety=st["variety"],
            )
            if resp.get("code") != 200:
                await query.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å MJ-–∑–∞–¥–∞—á—É: {resp.get('msg')}")
                st["_busy"] = False
                return

            task_id = (resp.get("data") or {}).get("taskId")
            await query.message.reply_text(f"üß© MJ –∑–∞–¥–∞—á–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞. taskId={task_id}\n‚è≥ –ò–¥—ë—Ç —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥‚Ä¶")

            for _ in range(60):
                pol = kie_poll("mj", task_id)
                if pol["final"]:
                    if pol["ok"]:
                        urls = extract_result_urls(pol["data"])
                        if urls:
                            medias: List[InputMediaPhoto] = []
                            for i, u in enumerate(urls[:4]):
                                medias.append(InputMediaPhoto(u, caption="‚úÖ –ì–æ—Ç–æ–≤–æ!" if i == 0 else None))
                            await query.message.reply_media_group(medias)
                        else:
                            await query.message.reply_text("‚úÖ –ì–æ—Ç–æ–≤–æ (–Ω–æ –±–µ–∑ —Å—Å—ã–ª–æ–∫ –≤ –æ—Ç–≤–µ—Ç–µ KIE).")
                    else:
                        await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ MJ: {pol.get('error','')}")
                    break
                await asyncio.sleep(10)
        finally:
            st["_busy"] = False
        return

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∫ –ø—Ä–æ–º–ø—Ç, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —Ä–µ–∂–∏–º–µ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏,
    –∏–ª–∏ –µ—Å–ª–∏ –æ–Ω —Ç–æ–ª—å–∫–æ —á—Ç–æ –Ω–∞–∂–∞–ª ¬´–ò–∑–º. –ø—Ä–æ–º–ø—Ç¬ª.
    """
    uid = update.effective_user.id
    st = get_state(uid)
    text = (update.message.text or "").strip()

    if st.get("_await_prompt"):
        st["prompt"] = text
        st["_await_prompt"] = False
        await update.message.reply_text("üß† –ì–æ—Ç–æ–≤–æ! –ü—Ä–æ–º–ø—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞—Ä—Ç–æ—á–∫—É.")
        return

    if st["mode"] in ("veo_text", "veo_photo", "mj_face"):
        st["prompt"] = text
        await update.message.reply_text("üß† –ì–æ—Ç–æ–≤–æ! –ü—Ä–æ–º–ø—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞—Ä—Ç–æ—á–∫—É.")
        return

async def on_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ñ–æ—Ç–æ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º file_id –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏.
    """
    uid = update.effective_user.id
    st = get_state(uid)
    ph = update.message.photo[-1]
    st["photo_file_id"] = ph.file_id
    st["_await_photo"] = False
    await update.message.reply_text("üñºÔ∏è –§–æ—Ç–æ –ø—Ä–∏–Ω—è—Ç–æ –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å.")

# ========================= App bootstrap =========================

def main() -> None:
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("health", health))

    app.add_handler(CallbackQueryHandler(on_cb))
    app.add_handler(MessageHandler(filters.PHOTO, on_photo))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), on_text))

    log.info("Bot started")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
